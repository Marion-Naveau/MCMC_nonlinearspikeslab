
R version 4.1.1 (2021-08-10) -- "Kick Things"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R est un logiciel libre livré sans AUCUNE GARANTIE.
Vous pouvez le redistribuer sous certaines conditions.
Tapez 'license()' ou 'licence()' pour plus de détails.

R est un projet collaboratif avec de nombreux contributeurs.
Tapez 'contributors()' pour plus d'information et
'citation()' pour la façon de le citer dans les publications.

Tapez 'demo()' pour des démonstrations, 'help()' pour l'aide
en ligne ou 'help.start()' pour obtenir l'aide au format HTML.
Tapez 'q()' pour quitter R.

INFO : Large data should be stored in your work/ folder. 
 
[Sauvegarde de la session précédente restaurée]

> rm(list=ls())
> 
> library(ggplot2)
> library(nlme)
> library(cowplot)
> library(glmnet)
Le chargement a nécessité le package : Matrix
Loaded glmnet 4.1-3
> library(mvnfast)
> library(doParallel)
Le chargement a nécessité le package : foreach
Le chargement a nécessité le package : iterators
Le chargement a nécessité le package : parallel
> library(microbenchmark)
> library(tidyverse)
── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ──
✔ tibble  3.1.6     ✔ dplyr   1.0.8
✔ tidyr   1.2.0     ✔ stringr 1.4.0
✔ readr   2.1.2     ✔ forcats 0.5.1
✔ purrr   0.3.4     
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ purrr::accumulate() masks foreach::accumulate()
✖ dplyr::collapse()   masks nlme::collapse()
✖ tidyr::expand()     masks Matrix::expand()
✖ dplyr::filter()     masks stats::filter()
✖ dplyr::lag()        masks stats::lag()
✖ tidyr::pack()       masks Matrix::pack()
✖ tidyr::unpack()     masks Matrix::unpack()
✖ purrr::when()       masks foreach::when()
> library(nonlinearspikeslab)
> library(nimble)
nimble version 0.12.2 is loaded.
For more information on NIMBLE and a User Manual,
please visit https://R-nimble.org.

Attachement du package : ‘nimble’

L'objet suivant est masqué depuis ‘package:stats’:

    simulate

> 
> source("nimble_fit_functions.R")
> 
> S=50                         #nb de simulations
> n <- 200 # nb d'individus
> J <- 10 # nb de repetitions
> p <- 700 # nb de covariables
> sigma2 <- 30 # variance residuelle des y
> Gamma2 <- 200 # variance inter-individuelle des phi_i
> mu <- 1200 # intercept
> beta <- c(100, 50, 20, rep(0, p - 3)) # vecteur d'effets fixes
> betatild <- c(mu, beta)
> c0 <- 200 # parametre de la fct g
> c2 <- 300 # parametre de la fct g, doit etre different de 0
> psi <- c(c0, c2)
> 
> g <- function(phi_i, psi, t_ij) {
+   return(psi[1] / (1 + exp(-(t_ij - phi_i) / psi[2])))
+ }
> 
> ncore = 10
> cl = makeCluster(ncore)
INFO : Large data should be stored in your work/ folder. 
 
INFO : Large data should be stored in your work/ folder. 
 
INFO : Large data should be stored in your work/ folder. 
 
INFO : Large data should be stored in your work/ folder. 
 
INFO : Large data should be stored in your work/ folder. 
 
INFO : Large data should be stored in your work/ folder. 
 
INFO : Large data should be stored in your work/ folder. 
 
INFO : Large data should be stored in your work/ folder. 
 
INFO : Large data should be stored in your work/ folder. 
 
INFO : Large data should be stored in your work/ folder. 
 
> registerDoParallel(cl)
> 
> nb_iter_finish=0
> save(nb_iter_finish,file="Nb_iter_Temps_MCMC_p700.Rdata")
> 
> Temps_Tot<-foreach(s = 1:S, .packages = c("nlme","mvnfast","doParallel","ggplot2","cowplot","glmnet","microbenchmark","tidyverse","nimble")) %dopar% {
+ 
+   print(s)
+   # Simulation du modèle
+   set.seed(s)
+   phi <- rep(0, n)
+   Vtild <- matrix(NA, nrow = n, ncol = p + 1)
+   Vtild[, 1] <- rep(1, n)
+   for (i in 1:n) {
+     # simulation de V_i
+     Vtild[i, 2:(p + 1)] <- rmvn(1, mu = rep(0, p), sigma = diag(1, p))
+   }
+   Vtild[, c(2:(p + 1))] <- scale(Vtild[, c(2:(p + 1))])
+   # simulation de phi_i
+   for (i in 1:n) {
+     phi[i] <- sum(betatild * Vtild[i, ]) + rnorm(1, mean = 0, sd = sqrt(Gamma2))
+   }
+   V <- Vtild[, -1]
+   # Simulation des données observées y
+ 
+   Y <- rep(0, n * J) # vecteur des y_ij avec y_ij=Y[(i-1)*J+j]
+   t <- rep(seq(150, 3000, length = J), n) # vecteur des t_ij avec t_ij=t[(i-1)*J+j]
+   for (i in 1:n) {
+     for (j in 1:J) {
+       Y[(i - 1) * J + j] <- g(phi_i = phi[i], psi = psi, t_ij = t[(i - 1) * J + j]) + rnorm(1, mean = 0, sd = sqrt(sigma2))
+     }
+   }
+ 
+   Id <- rep(c(1:n), each = J)
+   data <- data.frame(Id, Y, t)
+   id <- as.matrix(Id)
+   data2 <- data[id <= 30, ]
+   ggplot(data2, aes(x = t, y = Y, group = Id)) +
+     geom_point() +
+     geom_line() +
+     theme_bw()
+ 
+   data_input = data %>%
+     as_tibble() %>%
+     left_join(V %>%
+                 as_tibble() %>%
+                 rowid_to_column("Id")) %>%
+     rename(times = t, i = Id)
+ 
+   nu0=0.04
+   niter=3000
+ 
+   nimbleMCMC_object = OneVariableParamSpikeAndSlabDelay_marginal_delta_setup(data_input, nu_0 = nu0, niter = niter)
+ 
+   ## Time the execution for MCMC sampling (1 chain)
+   temps=TimeOneVariableParamSpikeAndSlabDelay_marginal_delta(Cmcmc = nimbleMCMC_object, nu_0 = nu0, niter = niter)
+ 
+   load("Nb_iter_Temps_MCMC_p700.Rdata")
+   nb_iter_finish=nb_iter_finish+1
+   save(nb_iter_finish,file="Nb_iter_Temps_MCMC_p700.Rdata")
+ 
+   temps
+ }
> stopCluster(cl)
> 
> save(Temps_Tot,file="Temps_MCMC_p700.Rdata")
> 
> load("Temps_MCMC_p700.Rdata") #Gamma2_init=500
> 
> temps=rep(0,50)
> for (s in 1:50){
+   temps[s]=Temps_Tot[[s]]
+ }
> temps
 [1] 409.9505 407.6718 411.2488 411.9989 410.6415 406.5006 402.9853 405.9430
 [9] 415.2648 400.5532 413.3455 410.4138 411.1858 410.8556 412.8709 412.3904
[17] 406.3341 411.5026 410.5316 413.8041 413.0522 410.7926 414.0070 411.4051
[25] 410.8999 412.7186 412.2201 412.9420 410.2137 414.4139 410.5145 407.0097
[33] 405.3851 408.4291 406.2746 402.7126 402.2631 401.8633 410.2584 406.0274
[41] 406.7625 404.3815 404.3199 402.0191 398.0032 405.5728 401.3288 401.2923
[49] 403.6925 408.0161
> min(temps)
[1] 398.0032
> mean(temps)
[1] 408.2957
> 
> proc.time()
utilisateur     système      écoulé 
      3.382       0.326    2345.243 

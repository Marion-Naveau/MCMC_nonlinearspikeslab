
R version 4.1.1 (2021-08-10) -- "Kick Things"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R est un logiciel libre livré sans AUCUNE GARANTIE.
Vous pouvez le redistribuer sous certaines conditions.
Tapez 'license()' ou 'licence()' pour plus de détails.

R est un projet collaboratif avec de nombreux contributeurs.
Tapez 'contributors()' pour plus d'information et
'citation()' pour la façon de le citer dans les publications.

Tapez 'demo()' pour des démonstrations, 'help()' pour l'aide
en ligne ou 'help.start()' pour obtenir l'aide au format HTML.
Tapez 'q()' pour quitter R.

INFO : Large data should be stored in your work/ folder. 
 
[Sauvegarde de la session précédente restaurée]

> rm(list=ls())
> 
> library(ggplot2)
> library(nlme)
> library(cowplot)
> library(glmnet)
Le chargement a nécessité le package : Matrix
Loaded glmnet 4.1-3
> library(mvnfast)
> library(doParallel)
Le chargement a nécessité le package : foreach
Le chargement a nécessité le package : iterators
Le chargement a nécessité le package : parallel
> library(microbenchmark)
> library(tidyverse)
── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ──
✔ tibble  3.1.6     ✔ dplyr   1.0.8
✔ tidyr   1.2.0     ✔ stringr 1.4.0
✔ readr   2.1.2     ✔ forcats 0.5.1
✔ purrr   0.3.4     
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ purrr::accumulate() masks foreach::accumulate()
✖ dplyr::collapse()   masks nlme::collapse()
✖ tidyr::expand()     masks Matrix::expand()
✖ dplyr::filter()     masks stats::filter()
✖ dplyr::lag()        masks stats::lag()
✖ tidyr::pack()       masks Matrix::pack()
✖ tidyr::unpack()     masks Matrix::unpack()
✖ purrr::when()       masks foreach::when()
> library(nonlinearspikeslab)
> library(tidyverse)
> 
> source("nimble_fit_functions.R")
> 
> S=50                         #nb de simulations
> n <- 200 # nb d'individus
> J <- 10 # nb de repetitions
> p <- 2000 # nb de covariables
> sigma2 <- 30 # variance residuelle des y
> Gamma2 <- 200 # variance inter-individuelle des phi_i
> mu <- 1200 # intercept
> beta <- c(100, 50, 20, rep(0, p - 3)) # vecteur d'effets fixes
> betatild <- c(mu, beta)
> c0 <- 200 # parametre de la fct g
> c2 <- 300 # parametre de la fct g, doit etre different de 0
> psi <- c(c0, c2)
> 
> g <- function(phi_i, psi, t_ij) {
+   return(psi[1] / (1 + exp(-(t_ij - phi_i) / psi[2])))
+ }
> 
> ncore = 10
> cl = makeCluster(ncore)
INFO : Large data should be stored in your work/ folder. 
 
INFO : Large data should be stored in your work/ folder. 
 
INFO : Large data should be stored in your work/ folder. 
 
INFO : Large data should be stored in your work/ folder. 
 
INFO : Large data should be stored in your work/ folder. 
 
INFO : Large data should be stored in your work/ folder. 
 
INFO : Large data should be stored in your work/ folder. 
 
INFO : Large data should be stored in your work/ folder. 
 
INFO : Large data should be stored in your work/ folder. 
 
INFO : Large data should be stored in your work/ folder. 
 
> registerDoParallel(cl)
> 
> nb_iter_finish=0
> save(nb_iter_finish,file="Nb_iter_Temps_MCMC_p2000.Rdata")
> 
> Temps_Tot<-foreach(s = 1:S, .packages = c("nlme","mvnfast","doParallel","ggplot2","cowplot","glmnet","microbenchmark","tidyverse","nimble")) %dopar% {
+ 
+   print(s)
+   # Simulation du modèle
+   set.seed(s)
+   phi <- rep(0, n)
+   Vtild <- matrix(NA, nrow = n, ncol = p + 1)
+   Vtild[, 1] <- rep(1, n)
+   for (i in 1:n) {
+     # simulation de V_i
+     Vtild[i, 2:(p + 1)] <- rmvn(1, mu = rep(0, p), sigma = diag(1, p))
+   }
+   Vtild[, c(2:(p + 1))] <- scale(Vtild[, c(2:(p + 1))])
+   # simulation de phi_i
+   for (i in 1:n) {
+     phi[i] <- sum(betatild * Vtild[i, ]) + rnorm(1, mean = 0, sd = sqrt(Gamma2))
+   }
+   V <- Vtild[, -1]
+   # Simulation des données observées y
+ 
+   Y <- rep(0, n * J) # vecteur des y_ij avec y_ij=Y[(i-1)*J+j]
+   t <- rep(seq(150, 3000, length = J), n) # vecteur des t_ij avec t_ij=t[(i-1)*J+j]
+   for (i in 1:n) {
+     for (j in 1:J) {
+       Y[(i - 1) * J + j] <- g(phi_i = phi[i], psi = psi, t_ij = t[(i - 1) * J + j]) + rnorm(1, mean = 0, sd = sqrt(sigma2))
+     }
+   }
+ 
+   Id <- rep(c(1:n), each = J)
+   data <- data.frame(Id, Y, t)
+   id <- as.matrix(Id)
+   data2 <- data[id <= 30, ]
+   ggplot(data2, aes(x = t, y = Y, group = Id)) +
+     geom_point() +
+     geom_line() +
+     theme_bw()
+ 
+   data_input = data %>%
+     as_tibble() %>%
+     left_join(V %>%
+                 as_tibble() %>%
+                 rowid_to_column("Id")) %>%
+     rename(times = t, i = Id)
+ 
+   nu0=0.04
+   niter=3000
+   nimbleMCMC_object = OneVariableParamSpikeAndSlabDelay_marginal_delta_setup(data_input,nu_0=nu0,niter=niter)
+ 
+   ## Time the execution for MCMC sampling (1 chain)
+   temps=TimeOneVariableParamSpikeAndSlabDelay_marginal_delta(Cmcmc = nimbleMCMC_object, nu_0 = nu0, niter = niter)
+ 
+   load("Nb_iter_Temps_MCMC_p2000.Rdata")
+   nb_iter_finish=nb_iter_finish+1
+   save(nb_iter_finish,file="Nb_iter_Temps_MCMC_p2000.Rdata")
+ 
+   temps
+ }
> stopCluster(cl)
> 
> save(Temps_Tot,file="Temps_MCMC_p2000.Rdata")
> 
> load("Temps_MCMC_p2000.Rdata") #Gamma2_init=500
> 
> temps=rep(0,50)
> for (s in 1:50){
+   temps[s]=Temps_Tot[[s]]
+ }
> temps
 [1] 4223.389 4166.673 4178.106 4159.845 4181.069 4092.022 4183.234 4146.776
 [9] 4108.198 4178.612 3376.907 3367.131 3356.689 3361.184 3353.127 3357.487
[17] 3364.521 3377.127 3376.651 3385.673 3378.694 3374.234 3375.262 3349.751
[25] 3370.670 3365.815 3380.242 3375.349 3360.487 3388.589 3440.879 3365.248
[33] 3359.844 3377.313 3366.778 3363.566 3380.773 3391.174 3384.364 3423.483
[41] 3381.680 3342.904 3358.621 3355.300 3354.416 3374.272 3376.164 3371.226
[49] 3364.991 3348.657
> min(temps)
[1] 3342.904
> mean(temps)
[1] 3529.903
> 
> 
> proc.time()
utilisateur     système      écoulé 
      2.595       0.263   18317.738 
